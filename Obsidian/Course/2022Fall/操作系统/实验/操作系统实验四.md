## 基础实验
- getpid()系统调用的功能：
	- 查询进行该系统调用的进程的pid，也就是这个进程在process数组中的下标
- Unix V6++系统调用执行过程：
	- 进行系统调用的进程进行模式切换，保存用户态运行现场，陷入核心
	- 进程调用系统调用的钩子（hook）函数，将系统调用的参数传入核心栈中
	- 进程调用系统调用处理函数，返回值存放在eax寄存器中
	- 假设该系统调用不需要入睡，则系统调用执行过程进程不会放弃cpu，优先级不变，从核心态返回时直接恢复用户态现场，继续执行
	- 假设该系统调用需要入睡，则将系统调用的优先数赋给该进程，之后这个进程执行swtch，放弃cpu并进入睡眠状态。等待下次被唤醒并上台时，恢复用户态运行现场，继续执行
- 添加一个新的系统调用的过程
	- 在systemCall中分别声明与定义对应的内核函数
	- 需要注意，内核函数返回值都为0，需要返回给调用者的内容应当存放在EAX寄存器中![[截屏2022-11-16 21.21.49.png]]
	- 在系统调用表中找到一个空的表项并且绑定刚才定义的函数，第一个参数表示该系统调用需要接收的参数数目![[截屏2022-11-16 21.22.17.png]]
	- 写钩子函数，功能为传入所需要的参数，并且接收返回值，放在sys.c中![[截屏2022-11-16 21.26.47.png]]
	- 设计校验程序，放在program文件夹中，调用刚才的hook函数检查功能，加入makefile并编译![[截屏2022-11-16 21.42.24.png]] ![[截屏2022-11-16 21.42.15 1.png]]
	- 进入终端，输入对应指令检查运行结果，符合预期![[截屏2022-11-16 21.46.14.png]]
## 附加题一
### 实验过程
- 其余过程基本相同
- 由于需要返回多个值，因此我在钩子函数中使用malloc申请了一段空间，并把指针的值作为参数传入系统调用中![[屏幕截图 2022-11-17 005304 1.png]]
- 接下来，编写对应的系统调用函数，从text与process结构中取得物理地址，从MemoryDescriptor中取得逻辑地址，将user结构的虚拟地址进行地址映射，由于其在核心区，直接减3G就可以得到物理地址，除以4K就得到MemoryDescriptor的物理页框号
	- 此处取系统调用的参数实际上由EBX传入，只是因为EBX在u_arg中下标也是0，等于EAX的宏定义值，因此可以恰好访问到，实际上应当直接用0访问![[屏幕截图 2022-11-17 005150.png]]
- 同样编写如下的测试程序：![[屏幕截图 2022-11-17 005337.png]]
- 输出结果如下：![[屏幕截图 2022-11-17 005500.png]]
### 寄存器分析
- trap函数中将ebx、ecx、edx、esi、edi五个寄存器用于存放系统调用的参数，接收参数之后这些寄存器不再作用，因此这五个通用寄存器一定是可以在系统调用过程中使用的，同时eax用于存放系统调用号，在系统调用中也可以修改。而其余通用寄存器、所有段寄存器和栈定位寄存器，其中存放了系统用户态运行重要的信息，不能随意修改
## 附加题二
在本实验的基础上，RSIC与CSIC分别有以下的优势与不足：
- RSIC具有较多的寄存器，可以在执行系统调用的过程中传入更多的参数，系统调用更加灵活，而CSIC寄存器数目较少，系统调用只能传入少量参数。
- RSIC指令种类较少，相对而言更不灵活，实现相同的功能需要更长的代码长度，增加了可执行程序的大小，占用宝贵的内核空间，而CISC由于指功能更复杂，代码段占用的空间较少。
