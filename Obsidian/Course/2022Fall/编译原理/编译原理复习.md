## 介绍
- 编译程序与解释程序的区别
	- 编译程序：会**产生目标语言程序**，使用原始数据交由目标语言程序执行，产生执行结果（转化系统）
	- 解释程序：源程序+原始数据经解释程序直接产生执行结果，不会产生目标语言程序（执行系统）
- 编译的过程：整个编译过程中，表格管理和错误处理贯穿其中![[Pasted image 20230215215930.png]]
	- 词法分析：将源程序转化为内部表示（Token list）
	- 语法分析：词法分析识别的符号转化为另一种内部表示（语法单位）
		- 语法单位：短语等，可以通过语法树等形式表示
	- 语义分析：生成中间代码（独立于硬件的记号系统）
		- 四元式的形式：（算符、运算对象1、运算对象2、结果）
	- 优化：对之前产生的中间代码加工，减少冗余代码
	- 目标代码生成：将中间代码转化为低级语言代码（需要进行寄存器分配等工作）
- “遍“以及相关概念
	- 遍：一个处理数据的完整周期（读出、处理、返回）
	- 一遍：相当于对源文件或者源文件产生的中间代码一次完整的扫描编译过程
	- 一遍扫描与多遍扫描：
		- 一遍扫描（编译）：内存占用多，但读写次数减少，速度更快
		- 多遍扫描（编译）：少占内存，但时间开销更大
	- **注意**：遍是物理上的划分，阶段是逻辑上的划分
		- 编译过程中，词法分析+语法分析+语义分析和中间代码生成三个阶段通常在一遍中完成
## 词法分析和自动机
- 文法的基本概念
	- 定义：用来定义语言的一个数学模型
		- Chomsky文法体系中，所有文法必须包含：
			- 终结符集合$V_T$
			- 非终结符集合$V_N$
			- 起始符号S
			- 一个形式规则的有限集合（产生式集合）
	- 分类：
		- 三型文法（正则文法、正规文法）：
			- 左线型文法和右线型文法![[Pasted image 20230216202451.png]]
			- 正则语言（正规语言）
			- 有限自动机（DFA、NFA）
		- 二型文法（上下文无关文法 CFG）：
			- 产生式：![[Pasted image 20230216202831.png]]
			- 上下文无关语言（CFL）
			- 下推自动机（PDA）
		- 一型文法（上下文有关文法 CSG）：
			- 产生式：![[Pasted image 20230216202905.png]]
			- 上下文有关语言（CSL）
			- 线性有界自动机（LBA）
		- 0型文法（无限制文法）：
			- 递归可枚举语言
			- 图灵机
	- 相关概念：
		- 语言：一个文法可以产生的所有句子的集合
		- 推导：
			- 直接推导：![[Pasted image 20230216204356.png]]
			- 推导（过程）：![[Pasted image 20230216204414.png]]
			- 最左/最右推导：每次替换句型中最左或最右的非终结符
		- 规约：推导的逆过程
		- 句型：可以从开始符号出发经过有限次推导产生的符号串称为文法的一个句型
		- 句子：仅由终结符组成的句型
		- 语言：一个文法可以产生的所有句子的集合
		- 语法树：表示一个句型推导的过程，是一棵倒立的树
			- 父节点都是非终结符
			- 子节点是对应产生式的右部
		- 二义性：
			- 句子的二义性：一个句子有两棵与之对应的语法树，说明这个句子是二义性的
			- 文法的二义性：一个文法**存在**二义性的句子，那么这个文法是二义性的
				- 文法的二义性不可判别（难以证明一个文法无二义性，但可以证明它有二义性）
			- 语言的二义性：一个语言可以对应很多个文法，若能找到一个文法不是二义性的，说明这个语言无二义性（若对应的每个文法都是二义性的，称这个语言是先天二义性的）
	- 词法分析器：输出（单词符号，属性值）二元组
	- 正规式与正规集
		- 正规式：
			- 单个字符、空集、空串是正规式
			- 闭包、连接、或，三种运算递归定义
		- 正规集：正规式能表示的句子的集合
	- DFA与NFA比较
		- DFA：
			- DFA的**每个状态**对于字母表的**每个符号**都定义有转移函数（与自动机中的定义不同，可以设置一个陷阱状态，不存在的转移直接转向trap状态）
			- DFA一个状态接受一个输入，下一个状态是确定的
		- NFA：
			- NFA的一个状态对于字母表的某个符号可能没有定义转移函数，或者存在空转移
			- NFA下一个状态不可确定，可能存在多个转移状态
	- **正规表达式到NFA：
		- 基础的三种生成：![[Pasted image 20230216211832.png]]
		- 三种归纳生成：
			- R+S                                                    ![[Pasted image 20230216211924.png]]
			- RS![[Pasted image 20230216211949.png]]
			- $R*$                                               ![[Pasted image 20230216212001.png]]
	- **NFA确定化为DFA
		- 定义：
			- I是状态集M的子集，I的epsilon-CLOSURE，记作epsilon-CLOSURE(I)定义如下：![[Pasted image 20230216212548.png]]
			- $I_a = \epsilon -CLOSURE(J)$其中J是从I中任意一个状态出发，经过一条a弧能到达的所有状态的集合
		- 方法：
			- 找到NFA的起始状态S
			- 构造$I=\epsilon -CLOSURE(S)$，对于所有非终结符v，构造$I_v$
			- 假设存在之前没有出现过的Iv，将其作为I，继续构造其所有的Iv
			- 重复以上步骤直到表中全部的项都出现过为止，将每一个CLOSURE作为一个新的状态，DFA构造完成![[Pasted image 20230216213159.png]]
		- 例子：68
	- **DFA化简：
		- 定义：
			- 状态s和t等价：分别从状态s和t出发，读入任意一个字符串a，如果s读入a能**到达终态**（终态集中的任意一个元素均可），则t读入a也能**到达终态**（可以不是同一状态，都属于终态集就行）。**并且**，假如s读入a无法到达终态，那么t读入a无法到达终态
			- 状态s和t可区分：s和t不等价
		- 步骤：![[Pasted image 20230216213802.png]]
		- 例子：85
## 自上而下分析方法
- 自上而下分析：对任何输入的句子，尝试从文法的开始符号出发，向下推导，推出句子，这个过程中自上而下地建立一棵语法树。**也就是为输入串找一个最左推导
- 左递归文法：
	- 定义：一个文法含有直接递归或者间接递归的产生式时，这个文法是左递归的
		- 直接递归：$A\to A\beta$
		- 间接递归：$A\to B\beta, B\to A\alpha$
	- **消除左递归：
		- 消除直接左递归：![[Pasted image 20230216214818.png]]
			- 生成的不含直接左递归的串作为新的开头，后面跟辅助符号P‘
			- P‘生成之前直接左递归产生式中P右边的所有串，右边接上一个P’。注意：**P’可以生成$\epsilon$
		- 消除左递归算法：![[Pasted image 20230216215308.png]]
		- 例子：113
- LL(1)文法：
	- 自上而下的分析方法
	- 条件：
		- （1）文法消除了左递归
		- （2）文法中**每个非终结符A**的**各个产生式**的FIRST集合两两不相交![[Pasted image 20230218211636.png]]
		- （3）对某个非终结符A，如果FIRST(A)中包含epsilon，那么FIRST(A)与FOLLOW(A)不相交
			- 构造表时，如果epsilon属于FIRST(A)，则对于所有属于FOLLOW(A)的元素b，M[A,b]应当填充$A\to \epsilon$，若不满足以上条件，则还存在某个产生式$A\to \alpha$满足某个b属于FIRST(alpha)，这一项就会产生冲突
	- 处理：
		- 消除左递归满足条件1
		- 后两个问题是由于文法存在回溯，是文法自身的问题，无法解决
			- 回溯的定义：但目前输入串队首符号为a，符号栈栈顶元素为A，如果A的所有产生式右部中存在一个以上的FIRST集合中含有a，那么就有回溯** **（简单的理解：不知道用那个产生式对A进行展开）**
	- **分析方法：
		- 满足LL(1)要求的文法，对于某个输入串可以进行无回溯的自上而下分析![[Pasted image 20230219182037.png]]
- **FIRST集合（终结首符集）
	- 定义：某个符号串经过若干次推导产生的所有**句子**的第一个终结符的集合![[Pasted image 20230218212909.png]]
	- 构造FIRST(X)，X是单个符号![[Pasted image 20230218213241.png]]
	- 构造FIRST(alpha)，alpha是符号串![[Pasted image 20230218213356.png]]
- **FOLLOW集合
	- 定义：对于非终结符A，从起始符号S开始，推出的包含A的句型中，A后面紧跟着的第一个非终结符的集合
		- **FOLLOW(A)中不会包含epsilon，但可能包含终结符号#**（#最多只会在输入终结符串的最后出现一次）
	- 构建FOLLOW(A)：![[Pasted image 20230219181758.png]]
- 递归下降分析程序：适用于能够实现递归过程的编译系统
	- 对每个非终结符A，编写相应的以下形式的P(A)（与LL(1)分析方法的思路对应）![[Pasted image 20230219182416.png]]
	- 对符号串alpha，处理的程序如下：![[Pasted image 20230219182756.png]]
- 预测分析程序：使用分析表和符号栈联合控制，实现LL(1)分析的另一种方法
	- LL(1)预测分析表：假设文法有m个终结符和n个非终结符
		- 分析表尺寸：$(m+1)(n+2)$（包括行、列标题）
			- 非终结符还有我们添加的#，只会且一定会在输入串末尾出现一次
		- M[A,a]：表示栈顶非终结符为A，且输入串首字符为a时，应当使用的产生式或出错标志
	- 栈：存放分析过程中的文法符号（终结符和非终结符）
		- 分析开始时，栈中先压入一个#，再压入其实符号S
		- 栈中仅剩下#，且输入串只剩下末尾的#时，分析结束
	- 总控程序：栈顶符号x（终结符或非终结符），串首符号a（一定是终结符）
		- 读入输入串，#压栈、起始符号S压栈
		- x = a = # ，分析结束
		- x = a !=#，栈顶弹出x，输入串指针后移
		- x为非终结符A，查表M[A,a]，输入串指针不移动
			- M[A,a]是一个右部不为空产生式，A出栈，产生式右部所有符号逆序压栈（最左边的先压栈）
			- M[A,a]是右部为空的产生式（$A\to \epsilon$），A出栈，没有符号入栈
			- M[A,a]为空，相当于出现语法错误，调用出错程序处理，分析结束
	- 输出：总控程序的输出就是最左推导的产生式（每次查表匹配，输出一个产生式）
	- **预测分析表的构造：
		- 对每个产生式$A\to \alpha$执行
			- 若a属于FIRST(alpha)，M[A,a]=$A\to \alpha$
			- 若epsilon属于FIRST(alpha)，对所有b属于FOLLOW(alpha)，有M[A,b]=$A\to \epsilon$
		- 其余表项置空，相当于出错
	- 分析：
		- 预测分析表中任意一项M[A,a]不存在多重入口（每个表项只匹配一个产生式），说明文法是LL(1)文法
		- LL(1)文法不可能是二义性文法，如果存在二义性，在构造预测分析表的时候会产生冲突
## 自下而上分析方法
- LR(0)、LR(1)、SLR(0)、算符优先分析方法属于自下而上的分析方法
- 自下而上的分析法（移进归约法）：
	- 使用一个符号栈，输入符号逐一入栈，当栈顶形成某一个产生式右部时，将栈顶这一部分替换（归约）为该产生式的左部符号
	- 基本操作：
		- 移进：下一个符号进栈，输入串读取指针后移
		- 归约：检查栈顶若干符号是否可以归约，若可以，用产生式左部代替栈顶若干符号，并输出对应的产生式（这些符号出栈，左部进栈）
		- 接受：当栈中只剩下栈底符号和文法开始符号，并且输入串读取指针指向输入串末尾，规约分析结束
		- 出错：发现错误，结束分析，调用出错处理程序
- **概念：
	- 短语：是一个符号串
		- 假设G是一个文法，S是其开始符号，$\alpha \beta \gamma$是文法G的一个句型，如果$\alpha A \gamma$也是G的一个句型，且A经过至少一次推导能产生beta，那么beta是**句型**$\alpha \beta \gamma$对于**非终结符**A的短语
		- 理解：句型语法树的每棵子树，其所有叶子节点从左到右形成的符号串是短语（句型的语法树叶子节点不一定是终结符）
	- 直接短语：特殊的短语，一定存在某个产生式，直接短语是它的右部
		-  假如有产生式$A \to \beta$，那么beta是**句型**$\alpha \beta \gamma$对于**产生式**$A \to \beta$的直接短语
		- 理解：只有父子两层子树形成的短语
	- 句柄：特殊的直接短语
		- 一个句型的**最左直接短语**称为句柄
		- 理解：最左的那棵只有父子两代的子树形成的短语
		- 注意：二义性文法，由于对于某个句型，可能存在不止一颗语法树，因此每个句型的句柄可能不唯一
	- 规范归约：不断将句型的句柄进行归约，直到得到文法起始符号的归约过程![[Pasted image 20230219204037.png]]
		- 基本问题：
			- 如何找出并确定可归约串（句柄）
			- 找出的句柄应该归约为哪一个非终结符
		- 素短语：算符优先分析方法中的可归约串
			- 至少包含一个终结符（算符）的d，且**除了自身之外不包含任何更小的素短语**（也就是不存在至少包含了一个终结符的子树）
		- 最左素短语：语法树中最左边那个素短语
			- 算符优先算法的最左素短语：![[Pasted image 20230220155505.png]]
	- 活前缀：规范句型的一个前缀，**不能包含任何句柄之后的符号
		- LR分析过程中，栈中的文法符号从栈底向上应该构成一个活前缀
- **一些求解方法：
	- 求句柄、短语、直接短语：先画出句型的语法树，从语法树中寻找
- 算符优先分析方法：
	- **算符优先分析方法不是规范归约**，规范归约使用句柄（最左直接短语）进行归约，算符优先分析方法采用最左素短语进行归约。规约速度快，但容易误判
	- 思想：定义终结符（算符）的优先关系，按终结符优先顺序控制自下而上的语法分析过程。
	- 定义：
		- 算符文法：一个文法，假设其**任意的一个产生式的右部**均不包含两个并列的非终结符（不存……QR……这种形式，其中QR都是非终结符）则该文法称为算符文法
		- 算符优先关系：![[Pasted image 20230219210715.png]]
			- 以上优先关系**并不具有自反性，也就是在a>b的情况下不一定有b>a，同样，a=b的情况下也不一定有b=a
			- 以上优先关系，**在某一句型中a在b的左侧，则a位于优先关系的左侧，不能反过来
			- 以上优先关系，需要满足a、b之间最多有一个非终结符时才成立（可以一个也没有，a、b并列，但一定不能超过两个）
			- 在满足以上三点的前提下，先归约（后推导）的优先级高，后归约（先推导）的优先级低，一起归约（同时推导）优先级相同
				- **再次强调，此处的高、低不具有自反性，a比b高，也就是a>b，不一定有b比a低，也就是b< a
		- 算符优先文法：![[Pasted image 20230219211706.png]]
			- 一对算符只能有一种优先关系
			- **(a,b)和(b,a)是顺序不同的两对，没有直接关联
	- 优先关系表的构造：
		- FIRSTVT(P)和LASTVT(P)集：P是非终结符，与FIRST和LAST集合没任何关系
			- 定义：![[Pasted image 20230219212154.png]]
				- 解释：分别是从非终结符P开始，经过若干步推导产生的句型中，左边或右边最多只有一个非终结符的$V_T$（终结符）的集合
			- **构造：
				- 思路：FIRSTVT与LASTVT的构造采用类似的规则（推导结果中，最左、最右边的**终结符的集合**并上最左、最右边**非终结符的FIRSTVT或LASTVT集合）![[Pasted image 20230219212426.png]]
				- 数据结构：![[Pasted image 20230219212847.png]]
				- 具体算法（以FIRSTVT为例，LASTVT构造算法基本相同）：
					- 找出所有符合规则1的（可以直接看出来）非终结符、终结符对[P,a]，将F[P,a]置为True，并将它们全部送入栈中
					- 从栈顶去除一对，记作[Q,a]，对所有形如$P\to Q...$的产生式，假设F[P,a]为False，就将其置为True，并送[P,a]进栈
					- 重复以上操作直到栈为空
				- 注意：为了处理符号#，可以在原本的文法中加入一个新的产生式，$E\to  \# S\#$，其中S为原本的起始符号
					- #=#
					- #<FIRSTVT(S)
					- LASTVT(S)>#
		- 有了FIRSTVT、LASTVT集合，我们就可以构造优先关系表：
			- 对于存在a=b关系的终结符对(a,b)，从产生式中直接就可以看出来
			- 对于存在>、<关系的终结符对(a,b)，使用以下规则构造![[Pasted image 20230219213942.png]]
				- 在后面的，找FIRSTVT集合，确定<关系
				- 在前面的，找LASTVT集合，确定>关系
				- 以下算法可以概括上述过程，实际上就是先找相等的，再找不等的：![[Pasted image 20230219214248.png]]
	- 优先函数：优先关系表的线性化
		- f(x)、g(x)，分别代表x位于优先关系左边、右边的优先数值![[Pasted image 20230220161425.png]]
		- **很多优先关系表不存在优先函数
		- 构造方法：![[Pasted image 20230220161740.png]]
			- 对于符号对(a,b)，a在左边，操作的一定是f(a)，b在右边，一定操作g(b)
			- 等于，画双向边
			- 不等于，从大的向小的画边
			- **可能矛盾，最后需要检查
	- 算法具体步骤：找最左素短语并且进行归约
		- 先压栈，直到出现>关系，说明最左素短语尾部符号已经位于栈中
		- 在栈中向前找，找到第一个<关系，中间的部分就是最左素短语
			- 假设一直找到栈底都发现没有<，说明出错
		- 最左素短语归约为某个非终结符N（规约的结果不用进栈）
- LR分析方法：严格的规范归约
	- 原理：在移进、规约的过程中寻找句柄
		- 历史：分析栈中已经移进和规约的字符串
		- 展望：依据当前使用的产生式预测未来可能遇到的输入符号
		- 现实：当前的输入符号
	- **LR文法的判定：
		- 对于一个文法，如果能构造一张LR分析表，使得它的每个入口是唯一确定的，则这个文法是LR文法
		- LR(k)文法：每步最多向前检查（展望）k个输入符号，就可以用LR分析器进行分析
			- 大多数语言属于LR(1)文法
			- LR(0)文法：只依据当前输入的符号和历史信息就能分析，不需要展望
	- Action表和Goto表：
		- 定义：
			- Goto[S,A]：定义栈顶状态S，对于符号栈顶符号A时，应当将状态Goto[S,A]压入符号栈
			- Action[S,a]：定义栈顶状态S接收到输入符号a（终结符）的时候，应该进行的动作
				- 移进：表中填写的是下一状态S'，将S'压入状态栈，a压入符号栈
				- 规约：表中填写的是用于规约的产生式编号，假设产生式右部长度为n
					- 首先，此时符号栈栈顶一定是产生式右部的n个字符，将这n个字符出栈。产生式左部非终结符A压栈（归约时，读写头不移动，a不压栈）
					- 接下来，将状态栈栈顶n个状态出栈
					- 假设这时状态栈栈顶状态是S‘’，查询Goto[S'',A]，将对应状态压入状态栈
				- 接受：表中填写Acc，代表分析成功结束
				- 报错：不是以上三种说明出现错误
		- 求Action表和Goto表：
			- 构造状态转移DFA：
				- LR(0)项目：文法G的产生式右部加一个圆点，称为G的一个LR(0)项目，![[Pasted image 20230220185654.png]]
				- 增广文法：
					- 假设原本文法G的起始状态为E，G对应的增广文法G‘就是在G中引入一个新的文法符号S，作为G’的开始状态。并添加一条新的产生式$S\to E$
				- 方法一：识别活前缀的NFA方法（不常用）
					- 将G转化为增广文法G‘
					- LR(0)项目$S\to .E$作为NFA的唯一初态，任何状态（包括终态）均认为是NFA的终态![[Pasted image 20230220190553.png]]
				- **方法二：LR(0)项目集规范族
					- 项目集I（包含一系列LR(0)项目）的闭包CLOSURE(I)
						- I的任何项目都属于CLOSURE(I)
						- 若$A\to \alpha .B\beta$属于CLOSURE(I)，那么对于任何关于B的产生式$B\to \gamma$，项目$B\to .\gamma$也属于CLOSURE(I)
						- 重复以上步骤直到CLOSURE(I)不再增大
					- 状态转换函数GO(I,X)：将项目集连接成DFA
						- I是一个项目集，X是一个文法符号
						- GO(I,X)=CLOSURE(J)，假设$A\to \alpha .B\beta$属于项目集I，那么$A\to \alpha B.\beta$属于CLOSURE(J)
							- 注意，点之后的如果是非终结符D，还要将C的产生式对应的所有项目$C\to .\gamma$加入CLOSURE(J)
					- 构造算法：
						- 首先将文法G转化成增广文法G‘
						- LR(0)项目集规范族$C=\{ CLOSURE({S\to .S})\}$，$CLOSURE({S\to .S})$是DFA的初始状态
						- 对C中的每个规范集I，对G’的所有符号X（可能是终结符或者非终结符），如果GO(I,X)非空且不属于C，则将其加入C族中
						- 重复以上操作直到C不再扩大
			- **构造LR(0)分析表的算法：
				- LR(0)项目规范族中，每个项目集添加一个下标，记作Ik，每个项目集作为一个状态
				- 包含$S'\to .S$的项目集作为分析器的初态
				- Action：考察DFA中边上是终结符的转移
					- 移进项：若项目$A\to \alpha .a\beta$属于Ik，且GO(Ik,a)=Ij，其中a是终结符，那么Action[k,a]=Sj（转移到状态j）
					- 归约项：若项目$A\to \alpha .$属于Ik，那么对于任何终结符（包括结束符号#），Action[Ik,a]=Rj（假设$A\to \alpha$是第j个产生式，表示使用这个产生式进行归约）
					- 若项目$S'\to S.$属于Ik，那么Action[Ik,#]=Acc
					- 其余Action表项为空，表示Error
				- Goto：考察DFA边上是非终结符的转移
					- GO(Ik,A)=Ij，A是非终结符，则GOTO[Ik,A]=Ij
					- 其余GOTO表项为空，表示出错
	- 算法流程：
		- 构建Action、Goto表
		- 输入串为源文件，最后加上#
		- 从起始状态开始，查表进行相应操作，直到ACC或者出错
	- LR(0)文法的局限性以及解决：
		- 可以发现，**规约项目$A\to \alpha .$不能和移进项目$A\to \beta .a\gamma$在同一个规范族中**，否则当输入a时，又可以移进，又可以规约，发生冲突
		- **SLR(1)冲突解决方法：移进终结符，和各个归约左部的FOLLOW集合不能相交![[Pasted image 20230220195632.png]]
	- 各种文法之间的关系：
		- LR(0)、SLR(1)、LR(1)、无二义文法，从后到前依次真包含![[Pasted image 20230220195852.png]]
		- LR(0)要求最严，能解决的问题最少
##  语法制导翻译
- 属性文法：每个文法符号联系于一组属性，并且对每个产生式给出语义规则
	- 属性：表示与文法符号相关的信息（比如值、符号表内容等），可以计算和传递
		- 综合属性：产生式左边符号的综合属性，是产生式右边文法符号的属性的函数 **（综合属性由子节点的属性确定）
		- 继承属性：产生式右边符号的继承属性，是产生式**左边或右边文法**符号的属性的函数 **（继承属性由副节点或兄弟节点的属性决定）
		- 说明：
			- **终结符只有综合属性**，由词法分析器提供
			- 非终结符可以有综合属性和继承属性，文法开始符号的所有继承属性作为属性计算前的初始值
			- **产生式左边的综合属性、右边的继承属性**，需要提供一个计算规则，只使用这个产生式中的文法符号属性计算
			- **产生式左边的继承属性、右边的综合属性**，由其他产生式的属性规则计算或者作为参数提供
- 基于属性文法的处理方法：
	- 依赖图：
		- 定义：为每个属性定义一个节点，若属性b依赖于属性c，从c向b画一条有向边
		- 构造算法：![[Pasted image 20230221164727.png]]
		- 例子：![[Pasted image 20230221164744.png]]
		- 说明：不存在循环依赖（图中没有环），说明是良定义的文法
	- 树遍历：
		- 思想：按深度优先、相同层从左到右次序遍历语法树，直到计算出所有的属性
			- 前提：需要提前建立语法树，并且树中已经具有**开始符号的继承属性**和**终结符的综合属性**
			- 可能需要遍历多次
		- 例子：已知S:a = 0![[Pasted image 20230221170404.png]]
			- 产生式，从左到右找非终结符，对每个非终结符，递归计算其继承属性（访问下一层的产生式）。所有继承属性计算出来之后算综合属性
- 语法制导翻译：为每个产生式配上一个翻译子程序（语义动作），并且在语法分析的同时执行它。
	- 使用一遍扫描的方法，在语法分析的过程中同步进行
	- 语义动作规定了产生式和产生式符号串的意义，并且按照这种意义规定了生成中间代码应该进行的基本动作
	- 在语法翻译过程中，**一个表达式用于归约（自下而上）或者获得匹配（自上而下）时，产生式对应的语义子程序进入工作
## 语义分析和中间代码生成
- 中间语言：介于源语言和目标语言之间，常用的中间语言如下
	- 后缀式（逆波兰表达式）
		- 定义：假设有一个表达式E
			- 假设E是一个常量或者变量，E的后缀式就是它本身
			- 假设E的形式为E1 op E2，其中op为任意二元操作符，那么E的后缀式为E1‘ E2’ op，其中E1‘、E2’分别是E1和E2的后缀式
			- **假设E的形式为(E1)，那么E1的后缀式就是E的后缀式
				- 因此，逆波兰表达式不需要括号，不管从哪一端扫描都能对它唯一分解
		- 计算过程：使用栈实现
			- 从左到右扫描后缀式，遇到运算量进栈，遇到k目运算符就将其作用到栈顶的k个运算量，将它们全部出栈，运算结果入栈
		- 表达式E翻译成后缀式：使用函数P(E)
			- $E\to id$：P(E)=id
			- $E\to (E1)$：P(E)=P(E1)
			- $E\to E1 op E2$：P(E)=P(E1)P(E2)op
	- 图表示法
		- 有向无循环图（DAG）
			- 表达式中每个子表达式，DAG中都有一个节点
			- 一个非叶子代表一个操作符，它的孩子代表操作数（求子树代表的表达式的值）
			- 一个DAG中，代表一个公共子表达式的节点具有多个父节点
			- 例子：![[Pasted image 20230221184629.png]]
		- 抽象语法树：在语法树中去掉对翻译不必要的信息（就是将DAG转化为树，公共子表达式建立多个子树）
			- mknode(op,left,right)：建立一个运算符号节点，标号（根节点）为op，left、right指向左右子树
			- mkleaf(id,entry)：建立一个标识符节点，标号为id，entry属性指向该标识符在符号表中的入口
			- mkleaf(num,val)：建立一个数节点，num为标号，val属性代表其数值
			- 例子：![[Pasted image 20230221185250.png]]
	- 三地址代码：
		- 定义：x := y op z，可以看作抽象语法树或者DAG的一种线性表示
			- 生成三地址代码时，抽象语法树中的内部节点使用临时变量存放
		- 常见的三地址代码种类：
			- 四元式：
				- 定义：带有4个域的记录结构，四个域分别称为op，arg1，arg2，result，参数和result通常为指向符号表中某一项的指针
					- 使用临时变量实现四元式之间的联系，临时变量也要放入符号表
					- 单目运算只使用arg1域
					- 转移语句，将目标标号放入reault域
				- 容易优化，但中间变量需要消耗存储空间
			- 三元式：
				- 定义：通过计算临时变量值的语句的位置来引用这个临时变量，三个域为op、arg1、arg2，其中arg可能是其他三元式的引用![[Pasted image 20230221202855.png]]
				- 使用了三元式指针，优化困难
			- 间接三元式
				- 定义：使用三元式表+简介码表表示中间代码![[Pasted image 20230221203038.png]]
					- 简介码表：按照运算的先后次序列出有关三元式在三元式表中的位置
				- 只需要优化简介码表，节省三元式表存储空间
- 布尔表达式的翻译：
	- 产生布尔表达式的文法：![[Pasted image 20230221211543.png]]
	- 数值表示法：
		- emit：将产生的三地址代码送入文件中
		- nextStat：输出序列中，下一条三地址语句的地址索引，每次emit，nextStat自动加一
		- 语义动作会在题目中给出
		- 例子：![[Pasted image 20230221212905.png]]
	- 作为条件控制的布尔表达式：
		- 条件语句：if E then S1 else S2
		- 赋予E两种出口，True和False![[Pasted image 20230221213020.png]]
		- 一遍扫描实现布尔表达式的翻译：
			- 采用四元式
			- 四元式存入一个数组中，数组下标代表四元式标号
			- 常用的四元式形式：![[Pasted image 20230221213725.png]]
			- 有时转移地址无法立刻知道，可以**将未完成的四元式地址作为语义值保存**，等待计算完成后回填
			- 非终结符E（E对应一个bool表达式）赋予两个综合属性**E.truelist和E.falselist**，分别记录E产生的布尔表达式对应的多个四元式中，需要回填“真”、“假”出口的四元式所构成的链表
			- 非终结符还有一个综合属性**E.nextlist**，记录S对应的语句执行完之后，需要回填转移地址的四元式所组成的链表
			- 为处理truelist和falselist，需要引入如下语义过程：
				- nextquad：指向下一条将要产生的四元式地址（下一次emit产生的四元式），每次emit，nextquad加一
				- makelist(i)：创建一个新的链表，其中只含有i一个元素（i是某个四元式的下标）
				- merge(p1,p2)：合并两条链表
				- backpatch(p,t)：回填，将p链表中，所有四元式的第四段（result作为转移地址），全部都填为t（t是一个地址）
- 控制语句的翻译：
	- if语句的翻译：
		- 相关产生式：![[Pasted image 20230221215105.png]]
		- 为了方便回填，将其改写为：![[Pasted image 20230221215136.png]]
	- While语句的翻译
		- 相关表达式：![[Pasted image 20230222140939.png]]
		- 为了方便回填，将其改写为![[Pasted image 20230222142552.png]]
- 产生四元式序列：
	- 先画语法树
	- 按照规范规约顺序，寻找指令发生的顺序
	- 按照指令发生的顺序列出指令，并进行相应的回填
## 符号表和运行时存储空间组织
- 符号表：
	- **符号表的作用：
		- 收集信息：包括源程序中的各种名字及其属性、特征等
		- 提供使用：
			- 上下文语义合法检查的依据
			- 目标代码生成阶段地址分配的依据
	- 符号表的基本操作：增删改查
	- 组织方式：
		- 直接方式：各栏长度固定，内容直接填入
			- 优点：易于组织、填写和查找
			- 缺点：空间浪费
		- 间接方式：内容填入其他数据结构中，表中存放指针
	- 类型：常量表、变量名表、过程名表、中间代码表……
	- 作用域的实现：
		- 方法1：引入“过程编号”属性（<名字，过程编号>）,并记录各个过程之间的层次关系，查找时，**先查找本过程编号的名字**，查不到就**查找外层过程编号的名字
		- 方法2：按照栈结构组织符号表，查找时从栈顶开始查找。
- 目标程序运行时的活动
	- 过程：
		- 定义：过程名+过程体
		- 调用：过程名出现在可执行语句中
		- 活动：过程的一次执行
		- 生存期：执行过程体第一步到最后一步之间的操作序列，包括该过程调用其他过程的操作
	- 参数传递：
		- 定义：调用和被调用过程之间通过参数（或全局量）来传递信息，有实参和形参的区分
		- 方式：
			- 传地址：
				- 定义：把实参的地址传给形参
				- 实现：
					- 调用段预先准备好实参的地址，方便被调用段访问
					- 进入被调用段后，程序将实参地址存入自己相应的形参单元中
					- 被调用过程对形参的访问处理成对形式单元的间接访问（通过地址访问），并且对每个指向同一实参的形参的赋值会立刻作用在实参上
				- 例子：每次修改形参单元，实参的值也会修改![[Pasted image 20230222155224.png]]
					- 实参的运算式，使用一个临时变量存放结果，运算结束后删除。指针指向临时变量
			- 得结果：
				- 定义：传地址的一种变形，但不等价
				- 实现：
					- 每个形参对应两个形式单元，一个存放实参地址，一个存放实参的值
					- 过程体中，对第二个形式单元（实参的值）直接访问
					- 结束后，将第二个形式单元的值放到第一个形式单元指向的实参单元中（最后写回结果）
				- 例子：结果和传地址**不一定相同**![[Pasted image 20230222155353.png]]
					- y对应的存放值的形参单元并没有改变，值还是2
					- 实参的运算式，使用一个临时变量存放结果，运算结束后删除
					- 多个形参指向同一个实参，按顺序写回，以最后写回的为准
			- 传值：
				- 定义：把实在参数的值传给对应的形式参数
				- 实现：
					- 调用段预先准备好实参的值，方便被调用段访问
					- 进入被调用段后，程序将实参的值存入自己相应的形参单元中
					- 被调用段中，形参单元当作局部数据访问
				- 例子：最简单，无论怎么修改，实参值都不会变
			- 传名（引用）：
				- 定义：在过程调用中，每一个形参都替换成相应的实参，也就是直接对实参进行访问
				- 实现：
					- 通常将每个实参处理成一个子程序（参数子程序），每次过程体中使用到对应的形参时，调用对应的子程序对实参进行访问和修改
				- 例子：结果和传地址**不一定相同**![[Pasted image 20230222155517.png]]
					- 直接进行替换，对形参的访问和修改就是对对应的实参（或实参的表达式）的访问和修改
- 存储空间的分配
	- 存储空间需求：一个目标程序运行所需要的存储空间包括
		- 存放目标代码的空间
		- 存放数据项目的空间
		- 存放程序运行所需要的控制数据单元的存储空间（控制栈）
	- 一个程序运行时的内存划分图示：                  ![[Pasted image 20230222162024.png]]
- 活动记录：                                                                    ![[Pasted image 20230223195558.png]]
	- 定义：为了管理一个过程活动，使用一个连续的存储块来存放所需要的信息，这个连续的存储块称为活动记录
		- 运行时，每当进入一个过程就有一个相应的活动记录被放到栈顶
	- 内容：
		- 连接数据：
			- 返回地址
			- 动态链：指针，指向**调用该过程的最新活动记录**地址（控制链）
			- 静态链：指针，指向静态**直接外层最新活动地址**的指针，**用于访问非局部数据（存取链）
		- 形式单元：存放相应实参的地址或值
		- 局部变量：局部变量、内情向量、临时工作单元
	- 访问：通过变址访问活动记录中的内容x，需要给出x相对于互动记录起点的地址
- 存储分配策略：
	- 静态分配策略（FORTRAN）：编译时可以确定数据空间的大小，在编译时为每个数据对象分配固定的存储单元，在运行的过程中始终不变
	- 动态分配策略（PASCAL）：编译时不可以确定数据空间的大小则必须动态编译，使用动态分配内存的方法，允许递归调用和动态申请内存
- 嵌套过程语言的栈式实现：
	- 仅使用静态链和动态链实现：以一下一段PASCAL程序为例：![[Pasted image 20230223200006.png]]
		- PASCAL语言规则，一个PASCAL过程如下：
			- 过程头;（主程序为program，其他为procedure）
				- 主程序没有参数，其他过程可能有，在过程名后括号中列出
			- 说明段：一系列说明语句，说明本段过程中的局部变量
				- 也可以说明子过程，子过程中也可以说明子过程，说明的子过程不会马上执行
			- 所有说明结束之后，begin
			- 执行体：主程序在执行体中调用其子过程
			- 执行体结束之后，end
		- 以上程序执行时R递归调用，栈如下所示：![[Pasted image 20230223201016.png]]
			- 静态链：直接外层，也就是指向**声明这个过程的过程在栈中起始的位置
				- 比如R是在Q中声明的，Q、S都是在P中声明的
			- 动态链，指向**调用自己的过程在栈中起始的位置，也就是指向之前的SP
			- 运行栈的结构（从下到上）：
				- 动态链，指向之前的SP
				- 返回地址
				- 静态链（主程序为0，表示它自己）
				- 形参个数（主程序没有）
				- 形参按次序压栈（主程序没有，其他过程可能没有形参）
				- 局部变量按次序（都有）
	- 嵌套层次显示表（Display）
		- 进入一个过程后，在活动记录去建立一张嵌套层次显示表Display，将其作为活动记录的一部分。**位置在形参和局部变量之间（主过程在静态链和局部变量之间）
			- 同时还需要构建一个全局display表（指针）指向**调用自己的过程的dispaly表开始的位置，在返回地址上面紧挨着
			- 去掉了静态链
		- Display表的内容：![[Pasted image 20230223202903.png]]
			- 最上面是自己的栈起始地址
			- 向下依次是自己的直接外层的栈起始地址（SP值）
			- 直接外层的直接外层的栈起始地址（SP值）
			- ……
		- 例子：![[Pasted image 20230223203034.png]]
			- 红色是display表，蓝色是全局display（替代了静态链的位置）
			- 从栈底开始依次是：
				- 老SP
				- 返回地址
				- 全局display（主过程为0）
				- 形参个数（主过程没有）
				- 形参顺序压栈（主过程没有，其他过程可能没有，也就是形参个数为0）
				- display表（主过程没有）
				- 局部变量（都有）
## 优化
- 局部优化
	- 定义：局部优化是基本块内的优化
	- 常用操作：
		- 删除公共子表达式
		- 删除无用赋值
		- 合并已知量（例如：T1 =2 ，T2 = T1 \* 4，转化为T2 = 8）
		- 临时变量改名
		- 交换语句位置
		- 代数变换
		- ……
	- 基本块
		- 定义：程序中一顺序执行语句序列，其中只有一个入口和一个出口，入口就是第一个语句，出口就是最后一个语句
		- 活跃：在一个基本块中的一个变量，在程序某个给定点是活跃的，是指在程序中，这个变量的值在这个点之后会被引用
		- 基本块的划分：
			- 求入口语句，有以下三种可能：
				- 程序**第一个语句
				- 条件转移或无条件转移转移语句**转移到的语句
				- **紧跟在条件转移语句之后的语句
			- 每个基本块，由一个入口语句和
				- 到下一个入口语句之间的语句 **（不包括下一个入口语句）组成**![[Pasted image 20230223211713.png]]
				- 或者，到下一个转移语句或停语句之间的语句 **（可以是条件或者无条件，且包括该转移语句或停语句）组成。            ![[Pasted image 20230223211739.png]]
			- **没有被纳入基本块内的语句，可以从程序中删除
		- 基本块的DAG表示
			- 叶节点：以标识符或者常数作为标记，表示变量或者常数的值
			- 内部节点：以一个运算符为标记，表示应用该运算符对其后继节点所代表的值进行这种运算的结果
			- 可以在各个节点上附加一个或多个标识符（代表一个或多个变量），表示这个变量具有该节点所代表的值
			- 几种表示方法：
				- ![[Pasted image 20230223214324.png]]
				- ![[Pasted image 20230223214342.png]]
				- ![[Pasted image 20230223214410.png]]
				- ![[Pasted image 20230223214424.png]]
					- 总结：
						- 父节点标识符，表示被赋值的对象、转移的目标
						- 直接赋值、无条件转移不需要子节点
			- 构造算法：对基本块中的每个四元式，执行以下操作
				- 准备操作数的结点
				- 合并已知量
				- 寻找公共子表达式
				- 删除无用赋值
				- 总结：等于常数的，直接等于常数、多用公共表达式。按照以上方法画出DAG，可以直接写出优化后的代码
				- 例子：
					- 优化前的代码![[Pasted image 20230223215606.png]]
					- 优化后的代码,出口后不活跃的丢弃，中间的临时变量有必要保留的保留![[Pasted image 20230223215640.png]]
						- 对于离开块后不活跃的，可以重复利用已有临时变量
	- 流图：
		- 定义：流图以基本块为节点，第一条语句是首语句的基本块对应首节点。假如在执行顺序中，基本块B1紧接着在B2之后执行，那么从B2向B1画一条有向边
		- 例子：![[Pasted image 20230223212321.png]]
- 循环优化：
	- 常用方法：
		- 代码外提
			- 概念：
				- 循环不变运算：四元式A = B op C，B和C在循环过程中值不会改变
				- 定值到达：变量A在某点d定值到达另一点u，指在流图中，d有一通路到达u且该通路上A的值不会改变
			- 算法：![[Pasted image 20230223221047.png]]
				- 不活跃、无逻辑矛盾，提到前置节点中。如果B、C在循环中被赋值，只有他俩的赋值语句都能外提并进行外提后，A才能外提
		- 强度削弱
			- 定义：把程序中执行时间较长的运算转化为执行时间较短的（比如将乘法运算用递归加法替代）
			- 例子：
				- 累加代替乘法（乘的是归纳变量）：![[Pasted image 20230223222248.png]]
				- T3是归纳变量，每次加一个常数代替访问T2![[Pasted image 20230223222429.png]]
		- 删除归纳变量（改变循环控制条件）
			- 基本归纳变量：循环中只对变量I进行I = I+C的赋值（C是个循环不变量），则I式基本归纳变量
			- 归纳变量：J在循环中的值总是I的**同一线性函数**，J = C1\*I + C2，C1和C2为循环不变量，那么J是和I同族的归纳变量
			- 例子：I出口chu不活跃，删除，改变循环终止条件![[Pasted image 20230223222536.png]]
		- 强度削弱和删除归纳变量统一算法：![[Pasted image 20230223221929.png]]
		- 循环展开
		- 循环合并
## 目标代码生成
- 基本问题
	- 代码生成器的输入：源程序的中间表示 + 符号表
	- **目标代码的三种形式：
		- 能立即执行的机器语言代码（所有地址已定位）
		- 带装配的机器语言代码（需要link）
		- 汇编语言代码
	- 指令选择：一致性和完整性
	- 寄存器分配：
		- 在寄存器分配期间，为程序的某一点选择驻留在寄存器中的一组变量
		- 寄存器指派阶段：挑选出代码将要驻留的寄存器（最优指派是NP问题）
	- 计算顺序选择
- 一个简单的代码生成器
	- 思想：在将四元式的中间代码变化成目标代码时，尽量在一个基本块的范围内考虑如何重复利用寄存器
		- 尽可能留：在生成计算某变量的目标代码时，尽量将该变量留在寄存器中
		- 尽可能用：后续代码尽量访问寄存器中的值，不访问内存
		- 及时腾空：离开基本块时，把存在寄存器中的现行值放在主存中
	- 待用信息：在一个基本块内，四元式i对A赋值，四元式j引用A的值，并且i到j之间没有其他代码对A赋值。那么称**j四元式i的变量A的待用信息
	- 活跃信息：在某个点之后这个变量会被引用，称这个变量在这个点是活跃的
	- 待用信息和活跃信息的表示：![[Pasted image 20230224004058.png]]
	- 计算待用信息和活跃信息：
		- 开始时，基本块中各个变量的待用信息为**非待用**，依据离开基本块后是否活跃（没说明都是不活跃），将活跃信息填为活跃或非活跃
		- 从基本块入口处开始，**从后到前**处理各个四元式，对每一个四元式A = B op C，依次执行以下步骤：![[Pasted image 20230224004432.png]]
		- 例子：![[Pasted image 20230224005551.png]]
	- 寄存器描述和地址描述：![[Pasted image 20230224005820.png]]
		- 说明：
			- 若寄存器在基本块之后活跃，则在当前基本块结束后将它的值放到它的主存单元中
			- **对形如A=B的四元式，如果B的值存放在某个寄存器中，无限生成目标代码，只需要在RVALUE(Ri)中添加一个A（同时把Ri填给B和A），并把AVALUE(A)改为Ri
	- 代码生成算法：![[Pasted image 20230224010223.png]]
	- 寄存器分配函数GETREG：
		- 尽可能用B独占的寄存器![[Pasted image 20230224011309.png]]
		- 尽可能用空闲寄存器![[Pasted image 20230224011337.png]]
		- 抢占用非空闲寄存器![[Pasted image 20230224011356.png]]
	- 例子：![[Pasted image 20230224011627.png]]
		- 最后把U也从寄存器中删除，释放空间，因为U已经不再活跃
		- W还活跃，需要将W写回内存中
